# $MirOS: src/bin/mksh/dot.mkshrc,v 1.30.2.2 2008/05/19 18:41:18 tg Exp $
#-
# ~/.mkshrc: mksh initialisation file for interactive shells

: ${EDITOR:=/bin/ed} ${TERM:=vt100} ${HOSTNAME:=$(ulimit -c 0;hostname -s 2>&-)}
[[ $HOSTNAME = @(localhost|*([	 ])) ]] && HOSTNAME=$(ulimit -c 0;hostname 2>&-)
: ${HOSTNAME:=nil}; if (( USER_ID )); then PS1='$'; else PS1='#'; fi
function precmd {
	typeset -i e=$?

	(( e )) && print -n "$e|"
}
PS1='$(precmd)${USER:=$(ulimit -c 0;id -un 2>&- || print \?)}@${HOSTNAME%%.*}:$(
	typeset pfx=~ wd=${PWD:-?}
	typeset -i n=${COLUMNS:-80}/3; (( n = n < 7 ? 7 : n ))
	[[ $pfx = ?(*/) ]] || wd=${wd/#$pfx/~}
	pfx=; while (( (${#pfx} + ${#wd}) > n )); do
		if [[ $wd = */* ]]; then
			pfx=.../
			wd=${wd#*/}
		else
			pfx=...
			wd=${wd#?????}
		fi
	done; print -nr -- "$pfx$wd") '"$PS1 "
PS1="$(print -n '\x1\r')$PS1"		# allow colour codes, framed with ^A
export EDITOR HOSTNAME LESSHISTFILE=- MKSH=$(whence -p mksh) PS1 TERM USER
alias ls=ls
unalias ls
alias l='ls -F'
alias la='l -a'
alias ll='l -l'
alias lo='l -alo'
alias which='whence -p'
whence -p rot13 >&- || alias rot13='tr \
    abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ \
    nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM'
whence -p hd >&- || function hd {
	hexdump -e '"%08.8_ax  " 8/1 "%02X " " - " 8/1 "%02X "' \
	    -e '"  |" "%_p"' -e '"|\n"' "$@"
}

# Berkeley C shell compatible dirs, popd, and pushd functions
# Z shell compatible chpwd() hook, used to update DIRSTACK[0]
DIRSTACKBASE=$(realpath ~/. 2>&- || print -nr -- "$HOME")
set -A DIRSTACK
function chpwd {
	DIRSTACK[0]=$(realpath . 2>&- || print -r -- "$PWD")
	[[ $DIRSTACKBASE = ?(*/) ]] || \
	    DIRSTACK[0]=${DIRSTACK[0]/#$DIRSTACKBASE/~}
	:
}
chpwd .
function cd {
	builtin cd "$@"
	chpwd "$@"
}
function cd_csh {
	typeset d t=${1/#~/$DIRSTACKBASE}

	if ! d=$(builtin cd "$t" 2>&1); then
		print -u2 "${1}: ${d##*$t - }."
		return 1
	fi
	cd "$t"
}
function dirs {
	typeset d
	typeset -i isnoglob=0 fl=0 fv=0 fn=0 cpos=0

	[[ $(set +o) == *@(-o noglob)@(| *) ]] && isnoglob=1
	set -o noglob
	while getopts ":lvn" d; do
		case $d {
		(l)	fl=1 ;;
		(v)	fv=1 ;;
		(n)	fn=1 ;;
		(*)	print -u2 'Usage: dirs [-lvn].'
			return 1 ;;
		}
	done
	shift $((OPTIND - 1))
	if (( $# > 0 )); then
		print -u2 'Usage: dirs [-lvn].'
		return 1
	fi
	if (( fv )); then
		fv=0
		while (( fv < ${#DIRSTACK[*]} )); do
			d=${DIRSTACK[fv]}
			(( fl )) && d=${d/#~/$DIRSTACKBASE}
			print -r -- "$fv	$d"
			let fv++
		done
	else
		fv=0
		while (( fv < ${#DIRSTACK[*]} )); do
			d=${DIRSTACK[fv]}
			(( fl )) && d=${d/#~/$DIRSTACKBASE}
			if (( fn && (cpos+=${#d}+1) >= 79 && ${#d} < 80 )); then
				print
				(( cpos = ${#d} + 1 ))
			fi
			print -nr -- "$d "
			let fv++
		done
		print
	fi
	(( isnoglob )) || set +o noglob
	return 0
}
function popd {
	typeset d fa
	typeset -i isnoglob=0 n=1

	[[ $(set +o) == *@(-o noglob)@(| *) ]] && isnoglob=1
	set -o noglob
	while getopts ":0123456789lvn" d; do
		case $d {
		(l|v|n)	fa="$fa -$d" ;;
		(+*)	n=2
			break ;;
		(*)	print -u2 'Usage: popd [-lvn] [+<n>].'
			return 1 ;;
		}
	done
	shift $((OPTIND - n))
	n=0
	if (( $# > 1 )); then
		print -u2 popd: Too many arguments.
		return 1
	elif [[ $1 = ++([0-9]) && $1 != +0 ]]; then
		if (( (n = ${1#+}) >= ${#DIRSTACK[*]} )); then
			print -u2 popd: Directory stack not that deep.
			return 1
		fi
	elif [[ -n $1 ]]; then
		print -u2 popd: Bad directory.
		return 1
	fi
	if (( ${#DIRSTACK[*]} < 2 )); then
		print -u2 popd: Directory stack empty.
		return 1
	fi
	unset DIRSTACK[n]
	set -A DIRSTACK -- "${DIRSTACK[@]}"
	cd_csh "${DIRSTACK[0]}" || return 1
	(( isnoglob )) || set +o noglob
	dirs $fa
}
function pushd {
	typeset d fa
	typeset -i isnoglob=0 n=1

	[[ $(set +o) == *@(-o noglob)@(| *) ]] && isnoglob=1
	set -o noglob
	while getopts ":0123456789lvn" d; do
		case $d {
		(l|v|n)	fa="$fa -$d" ;;
		(+*)	n=2
			break ;;
		(*)	print -u2 'Usage: pushd [-lvn] [<dir>|+<n>].'
			return 1 ;;
		}
	done
	shift $((OPTIND - n))
	if (( $# == 0 )); then
		if (( ${#DIRSTACK[*]} < 2 )); then
			print -u2 pushd: No other directory.
			return 1
		fi
		d=${DIRSTACK[1]}
		DIRSTACK[1]=${DIRSTACK[0]}
		cd_csh "$d" || return 1
	elif (( $# > 1 )); then
		print -u2 pushd: Too many arguments.
		return 1
	elif [[ $1 = ++([0-9]) && $1 != +0 ]]; then
		if (( (n = ${1#+}) >= ${#DIRSTACK[*]} )); then
			print -u2 pushd: Directory stack not that deep.
			return 1
		fi
		while (( n-- )); do
			d=${DIRSTACK[0]}
			unset DIRSTACK[0]
			set -A DIRSTACK -- "${DIRSTACK[@]}" "$d"
		done
		cd_csh "${DIRSTACK[0]}" || return 1
	else
		set -A DIRSTACK -- placeholder "${DIRSTACK[@]}"
		cd_csh "$1" || return 1
	fi
	(( isnoglob )) || set +o noglob
	dirs $fa
}

# strip comments (and leading/trailing whitespace if IFS is set) from
# any file(s) given as argument, or stdin if none, and spew to stdout
function Lstripcom {
	cat "$@" | { set -o noglob; while read _line; do
		_line=${_line%%#*}
		[[ -n $_line ]] && print -r -- $_line
	done; }
}

: place customsations above this line!
